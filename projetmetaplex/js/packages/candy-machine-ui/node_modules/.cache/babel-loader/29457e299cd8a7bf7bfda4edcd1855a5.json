{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = exports.getGatekeeperAccountAddress = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst constants_1 = require(\"./constants\");\n\nconst types_1 = require(\"../types\");\n\nconst GatewayTokenData_1 = require(\"./GatewayTokenData\");\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\n\n\nconst getGatekeeperAccountAddress = (authority, network) => __awaiter(void 0, void 0, void 0, function* () {\n  const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([authority.toBuffer(), network.toBuffer(), Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\")], constants_1.PROGRAM_ID);\n  return publicKeyNonce[0];\n});\n\nexports.getGatekeeperAccountAddress = getGatekeeperAccountAddress;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\n\nconst getGatewayTokenAddressForOwnerAndGatekeeperNetwork = (owner, gatekeeperNetwork, seed) => __awaiter(void 0, void 0, void 0, function* () {\n  const additionalSeed = seed ? Buffer.from(seed) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n\n  if (additionalSeed.length != 8) {\n    throw new Error(\"Additional Seed has length \" + additionalSeed.length + \" instead of 8 when calling getGatewayTokenAddressForOwnerAndGatekeeperNetwork.\");\n  }\n\n  const seeds = [owner.toBuffer(), Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"), additionalSeed, gatekeeperNetwork.toBuffer()];\n  const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n  return publicKeyNonce[0];\n});\n\nexports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork = getGatewayTokenAddressForOwnerAndGatekeeperNetwork; // Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\n\nconst GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2; // As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\n\nconst GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\n\nfunction fromGatewayTokenState(state) {\n  if (!!state.active) return types_1.State.ACTIVE;\n  if (!!state.revoked) return types_1.State.REVOKED;\n  if (!!state.frozen) return types_1.State.FROZEN;\n  throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\n\nconst dataToGatewayToken = (data, publicKey) => {\n  var _a;\n\n  return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\n\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens for a user on a gatekeeper network, optionally filtering out revoked tokens.\n *\n * Warning - this uses the Solana getProgramAccounts RPC endpoint, which is inefficient and may be\n * blocked by some RPC services.\n *\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\n\nconst findGatewayTokens = function (connection, owner, gatekeeperNetwork) {\n  let includeRevoked = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const ownerFilter = {\n      memcmp: {\n        offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n        bytes: owner.toBase58()\n      }\n    };\n    const gatekeeperNetworkFilter = {\n      memcmp: {\n        offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n        bytes: gatekeeperNetwork === null || gatekeeperNetwork === void 0 ? void 0 : gatekeeperNetwork.toBase58()\n      }\n    };\n    const filters = [ownerFilter, gatekeeperNetworkFilter];\n    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n      filters\n    });\n    if (!accountsResponse) return [];\n\n    const toGatewayToken = _ref => {\n      let {\n        pubkey,\n        account\n      } = _ref;\n      return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n    };\n\n    return accountsResponse.map(toGatewayToken).filter(gatewayToken => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);\n  });\n};\n\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Get a gateway token for the owner and network, if it exists.\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\n\nconst findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n  const gatewayTokenAddress = yield (0, exports.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(owner, gatekeeperNetwork);\n  const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n  if (!account) return null;\n  return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\n\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\n\nconst onGatewayTokenChange = function (connection, gatewayTokenAddress, callback) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.SOLANA_COMMITMENT;\n\n  const accountCallback = accountInfo => {\n    const gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n    callback(gatewayToken);\n  };\n\n  return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\n\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\n\nconst removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);\n\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\n\nconst getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {\n  const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n  if (!account) return null;\n  return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\n\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\n\nconst gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n  const gatekeeperAccount = yield (0, exports.getGatekeeperAccountAddress)(gatekeeperAuthority, gatekeeperNetwork);\n  const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n  return account != null && account.owner == constants_1.PROGRAM_ID;\n});\n\nexports.gatekeeperExists = gatekeeperExists;","map":{"version":3,"mappings":"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","names":["getGatekeeperAccountAddress","authority","network","__awaiter","publicKeyNonce","web3_js_1","findProgramAddress","toBuffer","Buffer","from","constants_1","exports","getGatewayTokenAddressForOwnerAndGatekeeperNetwork","owner","gatekeeperNetwork","seed","additionalSeed","length","Error","seeds","GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET","GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET","fromGatewayTokenState","state","active","types_1","ACTIVE","revoked","REVOKED","frozen","FROZEN","JSON","stringify","dataToGatewayToken","data","publicKey","issuingGatekeeper","toPublicKey","expiry","_a","toNumber","findGatewayTokens","connection","includeRevoked","ownerFilter","memcmp","offset","bytes","toBase58","gatekeeperNetworkFilter","filters","accountsResponse","getProgramAccounts","toGatewayToken","pubkey","account","GatewayTokenData_1","fromAccount","map","filter","gatewayToken","findGatewayToken","gatewayTokenAddress","getAccountInfo","onGatewayTokenChange","callback","commitment","accountCallback","accountInfo","onAccountChange","removeAccountChangeListener","id","getGatewayToken","gatekeeperExists","gatekeeperAuthority","gatekeeperAccount"],"sourceRoot":"","sources":["../../src/lib/util.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}